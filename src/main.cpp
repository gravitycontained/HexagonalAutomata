#include <qpl/qpl.hpp>

constexpr qpl::size max_distint_colors = 30;

namespace info {
	auto state_size = 4u;
	auto neighbours_radius = 4;
	auto hexagons_dimension = qpl::vec(300, 300);
	qpl::f64 empty_rule_chance = 0.5;
	qpl::f64 repeated_rule_change_chance = 0.9;
	qpl::f64 random_fill_chance = 2.0;
	qpl::size distinct_color_size = max_distint_colors;
	qpl::size neighbours_size;
	bool remove_switch_states = true;

	std::vector<qpl::rgb> distinct_colors;
	std::vector<qpl::rgb> state_colors;

	qpl::rgb get_random_color() {
		auto color = qpl::random_b(0.5) ? qpl::get_random_color() : qpl::get_random_rainbow_color();
		if (qpl::random_b(0.1)) color = qpl::random_b() ? qpl::rgb::white() : qpl::rgb::black();
		return color;
	}

	void reshuffle_state_colors() {
		auto stop = info::state_size - 1;
		if (info::distinct_color_size == max_distint_colors) {
			for (qpl::size i = 0u; i < stop; ++i) {
				state_colors[i + 1] = get_random_color();
			}
		}
		else {
			for (qpl::size i = 0u; i < stop; ++i) {
				state_colors[i + 1] = qpl::random_element(info::distinct_colors);
			}
		}
	}
	void make_state_colors() {
		state_colors.resize(info::state_size);
		state_colors[0] = qpl::rgb(20, 20, 20);

		info::distinct_colors.resize(info::distinct_color_size);
		for (auto& i : info::distinct_colors) {
			i = get_random_color();
		}

		info::reshuffle_state_colors();
	}
	void calculate_neighbours_size() {
		neighbours_size = qpl::size_cast(qpl::triangle_number(neighbours_radius) * 6 + 1);
	}
}


using neighbours_uint = qpl::u16;
using hexagon = qpl::u8;
constexpr auto undefined = qpl::type_max<hexagon>();


struct rule {
	struct association {
		qpl::vector<hexagon> result_table;
		qpl::size state_index;
	};

	qpl::vector<association> associations;

	void fix_boring_states() {
		for (auto& i : this->associations) {
			if (!i.result_table.empty()) {
				i.result_table.front() = undefined;
				i.result_table.back() = undefined;
			}
		}
	}

	void randomize() {
		hexagon random = qpl::random_b(info::empty_rule_chance) ? undefined : qpl::random(0u, info::state_size - 1);

		this->associations.resize(info::state_size);
		for (auto& i : this->associations) {
			i.result_table.resize(info::neighbours_size);
			for (auto& i : i.result_table) {
				if (qpl::random_b(1 - info::repeated_rule_change_chance)) {
					random = qpl::random_b(info::empty_rule_chance) ? undefined : qpl::random(0u, info::state_size - 1);
				}
				i = random;
			}
			i.state_index = qpl::random(0u, info::state_size - 1);
		}
		if (info::remove_switch_states) {
			this->fix_boring_states();
		}
	}
	void mutate() {
		qpl::size mode = qpl::random(0u, 2u);
		switch (mode) {
		case 0u:
			while (true) {
				auto& association = qpl::random_element(this->associations);
				auto before = association.state_index;
				association.state_index = qpl::random(0u, info::state_size - 1);
				if (association.state_index != before) {
					break;
				}
			}
			break;
		default:
			while (true) {
				auto& association = qpl::random_element(this->associations);
				auto& table = qpl::random_element(association.result_table);
				auto before = table;
				table = (mode == 1 ? undefined : qpl::random(1u, info::state_size - 1));
				if (table != before) {
					break;
				}
			}
		}
		if (info::remove_switch_states) {
			this->fix_boring_states();
		}
	}
	hexagon get(hexagon target, const std::vector<neighbours_uint>& neighbours) const {
		const auto& association = this->associations[target];
		auto value = association.result_table[neighbours[association.state_index]];
		if (value == undefined) {
			return target;
		}
		return value;
	}

	std::string info_string() const {
		std::ostringstream stream;
		for (qpl::size i = 0u; i < this->associations.size(); ++i) {
			stream << "for current state " << i << " and neighbour state " << (int)this->associations[i].state_index << "\n---";
			for (qpl::size a = 0u; a < this->associations[i].result_table.size(); ++a) {
				if (this->associations[i].result_table[a] != undefined) {
					stream  << a << " -> " << (int)(this->associations[i].result_table[a]) << ", ";
				}
			}
			stream << '\n';
		}
		return stream.str();
	}

	void save(std::string file) const {
		qpl::save_state state;
		state.save(info::state_size);
		state.save(info::neighbours_radius);
		state.save(info::random_fill_chance);
		state.save(info::empty_rule_chance);
		state.save(info::state_colors);
		for (auto& i : this->associations) {
			state.save(i.state_index);
			state.save(i.result_table);
		}
		state.file_save(file);
	}
	void load(std::string file) {
		qpl::load_state state;
		state.file_load(file);

		state.load(info::state_size);
		state.load(info::neighbours_radius);
		state.load(info::random_fill_chance);
		state.load(info::empty_rule_chance);
		info::calculate_neighbours_size();


		info::state_colors.resize(info::state_size);
		state.load(info::state_colors);

		info::distinct_color_size = 0u;
		std::unordered_set<qpl::rgb> seen;
		for (auto& color : info::state_colors) {
			if (seen.find(color) == seen.cend()) {
				info::distinct_colors.push_back(color);
				++info::distinct_color_size;
				seen.insert(color);
			}
		}
		info::distinct_color_size = qpl::min(info::distinct_color_size, max_distint_colors);

		this->associations.resize(info::state_size);
		for (auto& i : this->associations) {
			i.result_table.resize(info::neighbours_size);
			state.load(i.state_index);
			state.load(i.result_table);
		}
	}
};


struct hexagons {
	std::vector<hexagon> collection;
	qpl::vec2s dimension;
	rule rule;

	hexagons() {
		this->rule.randomize();
	}
	hexagon& operator[](qpl::size index) {
		return this->collection[index];
	}
	const hexagon& operator[](qpl::size index) const {
		return this->collection[index];
	}
	qpl::size size() const {
		return this->collection.size();
	}

	auto begin() {
		return this->collection.begin();
	}
	auto begin() const {
		return this->collection.cbegin();
	}
	auto cbegin() const {
		return this->collection.cbegin();
	}
	auto end() {
		return this->collection.end();
	}
	auto end() const {
		return this->collection.cend();
	}
	auto cend() const {
		return this->collection.cend();
	}

	hexagon get(qpl::isize x, qpl::isize y) const {
		if (x < 0 || x >= qpl::signed_cast(this->dimension.x) || y < 0 || y >= qpl::signed_cast(this->dimension.y)) {
			return hexagon{ 0 };
		}
		else {
			return this->collection[y * this->dimension.x + x];
		}
	}

	std::vector<neighbours_uint> count_neighbours(qpl::isize x, qpl::isize y) const {
		std::vector<neighbours_uint> result(info::state_size, 0);

		for (qpl::isize col = 0; col < info::neighbours_radius * 2 + 1; ++col) {
			auto width = (col + info::neighbours_radius + 1);
			if (col > info::neighbours_radius) {
				width = (info::neighbours_radius * 2 + 1) - (col - info::neighbours_radius);
			}

			for (qpl::isize i = 0; i < width; ++i) {

				auto dy = col - info::neighbours_radius;
				auto cy = y + dy;
				auto cx = x + i - info::neighbours_radius + (qpl::abs(dy) / 2);
				if ((dy % 2) && (y % 2)) cx += 1;

				if (cx >= 0 && cy >= 0 && cx < qpl::signed_cast(this->dimension.x) && cy < qpl::signed_cast(this->dimension.y)) {
					if (!(cx == x && cy == y)) {
						auto value = this->get(cx, cy);
						++result[value];
					}
				}
			}
		}

		return result;
	}
	void udpate() {
		auto copy = this->collection;
		for (qpl::isize y = 0; y < qpl::signed_cast(this->dimension.y); ++y) {
			for (qpl::isize x = 0; x < qpl::signed_cast(this->dimension.x); ++x) {
				auto neighbours = this->count_neighbours(x, y);

				auto& target = copy[y * this->dimension.x + x];
				target = rule.get(target, neighbours);
			}
		}
		this->collection = copy;
	}

	void clear() {
		this->collection.clear();
	}
	void create(qpl::vec2s size) {
		this->dimension = size;

		this->collection.resize(size.x * size.y);
	}
	void reset() {
		std::fill(this->collection.begin(), this->collection.end(), undefined);
	}
};

struct hexagon_shape {
	std::array<qpl::vec2, 18> vertices;

	constexpr static auto size = qpl::vec(50, 50);
	constexpr static auto hex_scale = qpl::sqrt(3.0) / 2;
	void create(qpl::vector2i position) {
		std::array<qpl::vec2, 6> angles{};

		constexpr auto scale = hexagon_shape::size * qpl::vec(hex_scale, 0.75);
		auto center = position * scale;

		if (position.y % 2) {
			center.x += scale.x / 2;
		}
		for (qpl::size i = 0u; i < 6u; ++i) {
			auto angle = 2 * qpl::pi * ((i + 0.5) / 6.0);
			auto x = std::cos(angle);
			auto y = std::sin(angle);
			angles[i] = qpl::vec(x, y) * (hexagon_shape::size * 0.5);
		}

		for (qpl::size i = 0u; i < 6u; ++i) {
			vertices[i * 3u + 0] = center;
			for (qpl::size k = 1u; k < 3u; ++k) {
				vertices[i * 3u + k] = angles[(i + k) % angles.size()] + center;
			}
		}
	}
};

struct hexagons_graphic {
	qsf::vertex_array va;
	hexagons before;

	std::vector<qpl::f64> heatmap;

	constexpr static auto use_heatmap = false;
	bool created = false;

	hexagons_graphic() {
		this->va.set_primitive_type(qsf::primitive_type::triangles);
	}

	void create(qpl::vec2s size) {
		auto dim = size.x * size.y;

		hexagon_shape hex;
		this->va.resize(dim * hex.vertices.size());
		this->heatmap.resize(dim, 0.0);

		qpl::size ctr = 0u;
		for (auto vec : size.list_possibilities_range()) {
			hex.create(vec);
			for (qpl::size i = 0u; i < hex.vertices.size(); ++i) {
				this->va[ctr * hex.vertices.size() + i].position = hex.vertices[i];
				this->va[ctr * hex.vertices.size() + i].color = qpl::rgb::white();
			}
			++ctr;
		}
		this->created = true;
	}

	void set(qpl::size index, qpl::rgb color) {
		for (qpl::size i = 0u; i < 18u; ++i) {
			this->va[index * 18 + i].color = color;
		}
	}
	void set(qpl::size index) {
		this->heatmap[index] += 0.1;
	}
	void set(qpl::size index, hexagon hexagon) {
		for (qpl::size i = 0u; i < 18u; ++i) {
			this->va[index * 18 + i].color = info::state_colors[hexagon];
		}
	}

	void update(const hexagons& hexagons) {
		if (!this->created) {
			this->before.clear();
			this->create(hexagons.dimension);
		}

		if (hexagons.dimension != before.dimension) {
			this->create(hexagons.dimension);
			before.dimension = hexagons.dimension;
			before.create(hexagons.dimension);
			before.reset();
		}
		for (qpl::size i = 0u; i < hexagons.size(); ++i) {
			if (this->before[i] != hexagons[i]) {
				this->before[i] = hexagons[i];
				if constexpr (use_heatmap) {
					this->set(i);
				}
				else {
					this->set(i, hexagons[i]);
				}
			}
			if constexpr (use_heatmap) {
				this->heatmap[i] *= 0.98;
				this->heatmap[i] = qpl::clamp_0_1(this->heatmap[i]);
				auto color = qpl::rgb::interpolation(std::vector{ qpl::rgb(20, 20, 20), qpl::rgb(100, 100, 255), qpl::rgb::white() }, this->heatmap[i]);
				this->set(i, color);
			}
		}
	}

	void draw(qsf::draw_object& draw) const {
		draw.draw(this->va);
	}
};

struct main_state : qsf::base_state {
	void init() override {
		info::calculate_neighbours_size();
		info::make_state_colors();

		this->print_commands();

		this->call_on_resize();

		this->hexagons.create(info::hexagons_dimension);
		this->graphic.update(this->hexagons);

		this->next_random_rule();

		auto width = 20;
		auto increase = 2;
		qpl::size slider_ctr = 0u;

		this->checkbox_switch_states.set_font("helvetica");
		this->checkbox_switch_states.set_character_size(20);
		this->checkbox_switch_states.set_dimension({ 20, 20 });
		this->checkbox_switch_states.set_position({ 650, 20 });
		this->checkbox_switch_states.set_value(info::remove_switch_states);

		this->slider_empty_rule.set_text_font("helvetica");
		this->slider_empty_rule.set_text_character_size(12);
		this->slider_empty_rule.set_text_color(qpl::rgb::grey_shade(150));
		this->slider_empty_rule.set_text_string("empty rule: ");
		this->slider_empty_rule.set_dimensions({ 600, 15 }, { 10, 15 });
		this->slider_empty_rule.set_position({ 20, width + (slider_ctr++) * (width + increase) });
		this->slider_empty_rule.set_range(0.0, 1.0, info::empty_rule_chance);
		this->slider_empty_rule.set_hitbox_increase(1);

		this->slider_repeated_rule_change = this->slider_empty_rule;
		this->slider_repeated_rule_change.set_text_string("repeated rule change: ");
		this->slider_repeated_rule_change.set_position({ 20, width + (slider_ctr++) * (width + increase) });
		this->slider_repeated_rule_change.set_range(0.0, 1.0, info::repeated_rule_change_chance);

		this->slider_random_fill = this->slider_empty_rule;
		this->slider_random_fill.set_text_string("random fill: ");
		this->slider_random_fill.set_position({ 20, width + (slider_ctr++) * (width + increase) });
		this->slider_random_fill.set_range(0.0, 6.0, info::random_fill_chance);

		this->slider_neighbour_radius = this->slider_empty_rule;
		this->slider_neighbour_radius.set_text_string("neighbour radius: ");
		this->slider_neighbour_radius.set_position({ 20, width + (slider_ctr++) * (width + increase) });
		this->slider_neighbour_radius.set_range(1, 15, 2);

		this->slider_state_size = this->slider_empty_rule;
		this->slider_state_size.set_text_string("state size: ");
		this->slider_state_size.set_position({ 20, width + (slider_ctr++) * (width + increase) });
		this->slider_state_size.set_range(2, 254, 4);

		this->slider_distinct_colors = this->slider_empty_rule;
		this->slider_distinct_colors.set_text_string("distinct colors: ");
		this->slider_distinct_colors.set_position({ 20, width + (slider_ctr++) * (width + increase) });
		this->slider_distinct_colors.set_range(1, 30, info::distinct_color_size);
		this->slider_distinct_colors.set_text_string_function([](auto s) { return s == max_distint_colors ? qpl::to_string("disabled") : qpl::to_string(s); });

		this->slider_dimension = this->slider_empty_rule;
		this->slider_dimension.set_text_string("dimension: ");
		this->slider_dimension.set_text_string_function([](auto s) {return qpl::to_string(s, " x ", s); });
		this->slider_dimension.set_position({ 20, width + (slider_ctr++) * (width + increase) });
		this->slider_dimension.set_range(10, 1000, 300);

		this->slider_empty_rule.set_text_string_function([](auto s) {return qpl::percentage_string(s); });
		this->slider_repeated_rule_change.set_text_string_function([](auto s) {return qpl::percentage_string(s); });
	}

	void print_commands() {
		qpl::println("'A'     - for slower update");
		qpl::println("'D'     - for faster update");
		qpl::println("'C'     - randomize state colors");
		qpl::println("'V'     - reshuffle state colors");
		qpl::println("'Q'     - load next rules/");
		qpl::println("'E'     - load previous rules/");
		qpl::println("'L'     - load random rule from rules/");
		qpl::println("'M'     - mutate current rule");
		qpl::println("'P'     - print current rule");
		qpl::println("'S'     - save current rule to rules/");
		qpl::println("'R'     - randomize state again");
		qpl::println("'X'     - toggle auto update mode");
		qpl::println("'<'     - return to previous rule");
		qpl::println("'>'     - return to next rule");
		qpl::println("'Space' - next random rule");
		qpl::println();
	}
	void call_on_resize() override {
		this->view.set_hitbox(*this);
	}
	void randomize_hexagons() {
		for (auto& i : this->hexagons) {
			i = 0u;
			if (qpl::random_b(1.0 / (std::pow(10, info::random_fill_chance)))) {
				i = qpl::random(0u, info::state_size - 1);
			}
		}
		this->graphic.update(this->hexagons);
	}
	void next_random_rule() {
		this->update_ctr = 0u;
		this->hexagons.rule.randomize();
		this->randomize_hexagons();
		if (this->previous_rule_ctr) {
			this->rules.reset();
		}
		this->rules.add(this->hexagons.rule);
		this->previous_rule_ctr = 0u;
	}
	void load_previous_rule() {
		if (!this->rules.empty() && this->previous_rule_ctr < this->rules.used_size()) {
			this->hexagons.rule = this->rules.get_previous(this->previous_rule_ctr);
			this->randomize_hexagons();
		}
		else {
			this->previous_rule_ctr = 0u;
		}
	}
	void reset_previous_rules() {
		this->rules.reset();
		this->previous_rule_ctr = 0u;
	}

	void update_slider_values() {
		this->slider_state_size.set_value(info::state_size);
		this->slider_neighbour_radius.set_value(info::neighbours_radius);
		this->slider_empty_rule.set_value(info::empty_rule_chance);
		this->slider_random_fill.set_value(info::random_fill_chance);
	}
	void load_next_file_rule() {
		qpl::filesys::path path = qpl::to_string(qpl::filesys::get_current_location(), "/rules/");
		auto files = path.list_current_directory();

		files.list_keep_where_extension_equals(".dat");

		if (!this->first_file_index_load) {
			++this->file_index;
			if (this->file_index >= files.size()) {
				this->file_index = 0u;
			}
		}
		this->first_file_index_load = false;

		qpl::println("loading \"", files[this->file_index], "\"");
		this->hexagons.rule.load(files[this->file_index]);
		this->rules.add(this->hexagons.rule);

		this->randomize_hexagons();
		this->update_ctr = 0u;
		this->update_slider_values();
	}
	void load_previous_file_rule() {
		qpl::filesys::path path = qpl::to_string(qpl::filesys::get_current_location(), "/rules/");
		auto files = path.list_current_directory();

		files.list_keep_where_extension_equals(".dat");

		if (!this->first_file_index_load) {
			if (!this->file_index) {
				this->file_index = files.size();
			}
			--this->file_index;
		}
		this->first_file_index_load = false;

		qpl::println("loading \"", files[this->file_index], "\"");
		this->hexagons.rule.load(files[this->file_index]);
		this->rules.add(this->hexagons.rule);

		this->randomize_hexagons();
		this->update_ctr = 0u;
		this->update_slider_values();
	}
	void load_random_rule() {
		qpl::filesys::path path = qpl::to_string(qpl::filesys::get_current_location(), "/rules/");
		auto files = path.list_current_directory();

		files.list_keep_where_extension_equals(".dat");

		auto index = qpl::random(0ull, files.size() - 1);

		this->file_index = index;
		qpl::println("loading \"", files[index], "\"");
		this->hexagons.rule.load(files[index]);
		this->rules.add(this->hexagons.rule);

		this->randomize_hexagons();
		this->update_ctr = 0u;
		this->update_slider_values();
	}
	void updating() override {
		this->update(this->slider_empty_rule);
		this->update(this->slider_repeated_rule_change);
		this->update(this->slider_random_fill);
		this->update(this->slider_state_size);
		this->update(this->slider_neighbour_radius);
		this->update(this->slider_dimension);
		this->update(this->slider_distinct_colors);
		this->update(this->checkbox_switch_states);

		if (this->checkbox_switch_states.is_clicked()) {
			info::remove_switch_states = this->checkbox_switch_states.get_value();
			this->next_random_rule();
		}

		if (this->slider_empty_rule.value_was_modified()) {
			info::empty_rule_chance = this->slider_empty_rule.get_value();
			this->next_random_rule();
		}
		if (this->slider_repeated_rule_change.value_was_modified()) {
			info::repeated_rule_change_chance = this->slider_repeated_rule_change.get_value();
			this->next_random_rule();
		}
		if (this->slider_random_fill.value_was_modified()) {
			info::random_fill_chance = this->slider_random_fill.get_value();
			this->randomize_hexagons();
		}
		if (this->slider_state_size.value_was_modified()) {
			info::state_size = qpl::u32_cast(this->slider_state_size.get_value());
			info::make_state_colors();
			this->reset_previous_rules();
			this->next_random_rule();
		}
		if (this->slider_neighbour_radius.value_was_modified()) {
			info::neighbours_radius = qpl::i32_cast(this->slider_neighbour_radius.get_value());
			info::calculate_neighbours_size();
			this->reset_previous_rules();
			this->next_random_rule();
		}
		if (this->slider_dimension.value_was_modified()) {
			info::hexagons_dimension = qpl::vec2i::filled(this->slider_dimension.get_value());
			this->hexagons.create(info::hexagons_dimension);
			this->graphic.update(this->hexagons);
			this->randomize_hexagons();
		}
		if (this->slider_distinct_colors.value_was_modified()) {
			info::distinct_color_size = this->slider_distinct_colors.get_value();
			info::make_state_colors();
			this->graphic.before.reset();
			this->graphic.update(this->hexagons);
		}

		bool dragging = (this->slider_empty_rule.dragging ||
			this->slider_random_fill.dragging || 
			this->slider_repeated_rule_change.dragging || 
			this->slider_state_size.dragging || 
			this->slider_neighbour_radius.dragging ||
			this->slider_dimension.dragging ||
			this->slider_distinct_colors.dragging);

		this->view.allow_dragging = !dragging;
		this->update(this->view);

		if (this->update_clock.has_elapsed_reset(this->update_delta)) {
			++this->update_ctr;
			this->hexagons.udpate();
			this->graphic.update(this->hexagons);
		}

		if (this->event().key_pressed(sf::Keyboard::A)) {
			this->update_delta *= 1.2;
		}
		else if (this->event().key_single_pressed(sf::Keyboard::H)) {
			this->hide_hud = !this->hide_hud;
		}
		else if (this->event().key_pressed(sf::Keyboard::D)) {
			this->update_delta *= 1.0 / 1.2;
		}
		else if (this->event().key_single_pressed(sf::Keyboard::L)) {
			this->load_random_rule();
		}
		else if (this->event().key_single_pressed(sf::Keyboard::Q)) {
			this->load_previous_file_rule();
		}
		else if (this->event().key_single_pressed(sf::Keyboard::E)) {
			this->load_next_file_rule();
		}
		else if (this->event().key_single_pressed(sf::Keyboard::S)) {
			auto file = qpl::to_string("rules/", qpl::get_current_time_string_ymdhmsms_compact(), "_rule.dat");
			this->hexagons.rule.save(file);
		}
		else if (this->event().key_single_pressed(sf::Keyboard::P)) {
			qpl::println(this->hexagons.rule.info_string(), "\n\n");
		}
		else if (this->event().key_single_pressed(sf::Keyboard::C)) {
			info::make_state_colors();
			this->graphic.before.reset();
			this->graphic.update(this->hexagons);
			if (!this->event().key_holding(sf::Keyboard::LShift)) {
				this->randomize_hexagons();
			}
		}
		else if (this->event().key_single_pressed(sf::Keyboard::V)) {
			info::reshuffle_state_colors();
			this->graphic.before.reset();
			this->graphic.update(this->hexagons);
			if (!this->event().key_holding(sf::Keyboard::LShift)) {
				this->randomize_hexagons();
			}
		}
		else if (this->event().key_single_pressed(sf::Keyboard::R)) {
			this->randomize_hexagons();
		}
		else if (this->event().key_pressed(sf::Keyboard::M)) {
			this->hexagons.rule.mutate();
			this->randomize_hexagons();
		}
		else if (this->event().key_single_pressed(sf::Keyboard::Space)) {
			this->next_random_rule();
		}
		else if (this->event().key_single_pressed(sf::Keyboard::X)) {
			this->auto_update = !this->auto_update;
			qpl::println("auto_update : ", qpl::bool_string(this->auto_update));
		}
		else if (this->auto_update && this->update_ctr > 125) {
			this->next_random_rule();
		}
		else if (this->event().key_single_pressed(sf::Keyboard::Left)) {
			if (this->previous_rule_ctr < this->rules.used_size()) {
				++this->previous_rule_ctr;
				this->load_previous_rule();
			}
		}
		else if (this->event().key_single_pressed(sf::Keyboard::Right)) {
			if (this->previous_rule_ctr) {
				--this->previous_rule_ctr;
				this->load_previous_rule();
			}
		}
	}
	void drawing() override {
		this->draw(this->graphic, this->view);
		if (!this->hide_hud) {
			this->draw(this->slider_empty_rule);
			this->draw(this->slider_repeated_rule_change);
			this->draw(this->slider_random_fill);
			this->draw(this->slider_state_size);
			this->draw(this->slider_neighbour_radius);
			this->draw(this->slider_dimension);
			this->draw(this->slider_distinct_colors);
			this->draw(this->checkbox_switch_states);
		}
	}

	hexagons hexagons;
	hexagons_graphic graphic;
	qsf::view_control view;

	qsf::slider<qpl::f64> slider_empty_rule;
	qsf::slider<qpl::f64> slider_repeated_rule_change;
	qsf::slider<qpl::f64> slider_random_fill;
	qsf::slider<qpl::size> slider_state_size;
	qsf::slider<qpl::size> slider_neighbour_radius;
	qsf::slider<qpl::size> slider_dimension;
	qsf::slider<qpl::size> slider_distinct_colors;
	qsf::check_box checkbox_switch_states;
	qpl::size file_index = 0u;
	bool first_file_index_load = true;

	qpl::circular_array<rule, 512> rules;

	qpl::small_clock update_clock;
	qpl::f64 update_delta = 0.01;
	qpl::size update_ctr = 0u;
	qpl::size previous_rule_ctr = 0u;
	bool auto_update = false;
	bool hide_hud = false;
};

int main() try {
	qsf::framework framework;
	framework.set_title("QPL");
	framework.add_font("helvetica", "resources/Helvetica.ttf");
	framework.set_dimension({ 1400u, 950u });

	framework.add_state<main_state>();
	framework.game_loop();
}
catch (std::exception& any) {
	qpl::println("caught exception:\n", any.what());
	qpl::system_pause();
}
